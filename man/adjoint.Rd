% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adjoint.R
\name{adjoint}
\alias{adjoint}
\title{Adjoint Sensitivity Analysis with Required Analytical Derivatives}
\usage{
adjoint(
  ode_func,
  jacobian_func,
  x0,
  params,
  times,
  data = NULL,
  objective_func = NULL,
  objective_grad = NULL,
  running_cost = NULL,
  running_cost_grad = NULL,
  rtol = 1e-08,
  atol = 1e-10,
  method = "lsoda",
  save_trajectory = FALSE
)
}
\arguments{
\item{ode_func}{Function(t, x, params, data) returning list with:
\itemize{
\item dx: derivative dx/dt (vector of length n_states)
}}

\item{jacobian_func}{REQUIRED function(t, x, params, data) returning list:
\itemize{
\item df_dx: Jacobian matrix ∂f/∂x (n_states x n_states)
\item df_dtheta: Jacobian matrix ∂f/∂θ (n_states x n_params)
}}

\item{x0}{Initial state vector}

\item{params}{Parameter vector θ (parameters to optimize)}

\item{times}{Time points for integration}

\item{data}{Optional list of constant data (not optimized)}

\item{objective_func}{Optional function(x_final, data) for terminal cost}

\item{objective_grad}{REQUIRED if objective_func provided:
function(x_final, data) returning ∂g/∂x (vector of length n_states)}

\item{running_cost}{Optional function(t, x, data) for running cost L(t,x)}

\item{running_cost_grad}{Optional but REQUIRED if running_cost provided:
function(t, x, data) returning ∂L/∂x (vector of length n_states)}

\item{rtol}{Relative tolerance for ODE solver (default 1e-8)}

\item{atol}{Absolute tolerance for ODE solver (default 1e-10)}

\item{method}{ODE solver method (default "lsoda")}
}
\value{
List containing:
\itemize{
\item objective: Value of objective function J
\item gradient: Gradient vector dJ/dθ
\item final_state: State at final time x(T)
\item sensitivity_final: Sensitivity matrix S(T) = ∂x(T)/∂θ
\item trajectory: Full state trajectory (if save_trajectory = TRUE)
}
}
\description{
Implements the adjoint sensitivity method for computing gradients.
This version REQUIRES analytical derivatives for efficiency and accuracy.
}
\details{
For an ODE system:
dx/dt = f(t, x, θ, data)
x(t0) = x0

And objective function:
J = g(x(T), data) + ∫\link{t0,T} L(t, x(t), data) dt

The adjoint method computes dJ/dθ efficiently using provided derivatives.
}
\examples{
\dontrun{
# Define ODE system
ode_func <- function(t, x, params, data) {
  list(dx = -params[1] * x)
}

# REQUIRED: Provide analytical Jacobians
jacobian_func <- function(t, x, params, data) {
  list(
    df_dx = matrix(-params[1], 1, 1),
    df_dtheta = matrix(-x, 1, 1)
  )
}

# Objective function
objective_func <- function(x_final, data) {
  (x_final - 0.5)^2
}

# REQUIRED: Provide objective gradient
objective_grad <- function(x_final, data) {
  2 * (x_final - 0.5)
}

result <- adjoint(
  ode_func = ode_func,
  jacobian_func = jacobian_func,
  x0 = 1,
  params = 0.5,
  times = c(0, 1),
  objective_func = objective_func,
  objective_grad = objective_grad
)
}
}

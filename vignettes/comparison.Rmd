---
title: "Comparison"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Comparison}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  message = FALSE,
  warning = FALSE
)
```


```{r load-packages, echo=FALSE}
library(JointODE)
library(JSM)
library(nlme)
library(survival)
library(ggplot2)
library(dplyr)
library(tidyr)
library(knitr)

set.seed(42)
```

## Simulation Setup

The `sim` dataset was generated using a joint ODE framework with the following structure:

**Longitudinal Process:**

The observed biomarker measurements are:
$$v_{ij} = m_i(t_{ij}) + b_i + \epsilon_{ij}$$

where the true biomarker trajectory $m_i(t)$ evolves according to:

$$\ddot{m}_i(t) = \beta_1 m_i(t) + \beta_2 \dot{m}_i(t) + \beta_3 + \beta_4 x_{i1} + \beta_5 x_{i2}$$

with $b_i \sim \mathcal{N}(0, \sigma_b^2)$ (random intercept) and $\epsilon_{ij} \sim \mathcal{N}(0, \sigma_e^2)$ (measurement error).

**Survival Process:**

The hazard function incorporates biomarker dynamics:
$$\lambda_i(t) = \lambda_0(t) \exp\{\alpha_1 m_i(t) + \alpha_2 \dot{m}_i(t) + \phi_1 w_{i1} + \phi_2 w_{i2} + b_i\}$$

where $\lambda_0(t)=8$ is the baseline hazard and $\alpha = (\alpha_1, \alpha_2)$ captures the association with biomarker value and velocity.

```{r params-data, echo=FALSE}
# Load data
long_data <- sim$data$longitudinal_data
surv_data <- sim$data$survival_data

# Display parameters
hazard_params <- sim$init$coefficients$hazard
accel_params <- sim$init$coefficients$acceleration

cat("True Parameters:\n")
cat(sprintf(
  "  Hazard: α = [%.1f, %.1f], φ = [%.1f, %.1f]\n",
  hazard_params[1], hazard_params[2], hazard_params[3], hazard_params[4]
))
cat(sprintf(
  "  ODE: β = [%.1f, %.1f, %.1f, %.1f, %.1f]\n",
  accel_params[1], accel_params[2], accel_params[3],
  accel_params[4], accel_params[5]
))
cat(sprintf(
  "  Variance: σ_e = %.1f, σ_b = %.1f\n",
  sim$parameters$coefficients$measurement_error_sd,
  sim$parameters$coefficients$random_effect_sd
))

cat(sprintf(
  "\nDataset: %d subjects, %d observations, %.0f%% events\n",
  n_distinct(long_data$id), nrow(long_data),
  100 * mean(surv_data$status)
))
```


### ODE Dynamics

```{r viz-combined, fig.width=10, fig.height=4, echo=FALSE}
library(patchwork)

# Select example subjects
set.seed(42)
example_ids <- sample(unique(long_data$id), 4)

# Left plot: ODE dynamics
dynamics_data <- long_data %>%
  filter(id %in% example_ids) %>%
  select(id, time, biomarker, velocity, acceleration) %>%
  pivot_longer(c(biomarker, velocity, acceleration),
    names_to = "component",
    values_to = "value"
  ) %>%
  mutate(component = factor(component,
    levels = c("biomarker", "velocity", "acceleration"),
    labels = c("m(t)", "dm/dt", "d²m/dt²")
  ))

p1 <- ggplot(dynamics_data, aes(x = time, y = value, color = component)) +
  geom_line(size = 0.8) +
  facet_wrap(~ paste("Subject", id), scales = "free_y", ncol = 2) +
  scale_color_manual(values = c("#27AE60", "#3498DB", "#9B59B6")) +
  theme_minimal(base_size = 10) +
  theme(legend.position = "top") +
  labs(
    title = "ODE Dynamics",
    subtitle = "True trajectories and derivatives",
    x = "Time",
    y = "Value",
    color = ""
  )

# Right plot: Measurement error
error_examples <- long_data %>%
  filter(id %in% example_ids)

p2 <- ggplot(error_examples, aes(x = time)) +
  geom_line(aes(y = biomarker, color = "True"), size = 1) +
  geom_point(aes(y = observed, color = "Observed"), alpha = 0.6, size = 1.2) +
  facet_wrap(~ paste("Subject", id), scales = "free_y", ncol = 2) +
  scale_color_manual(values = c("True" = "#27AE60", "Observed" = "#E74C3C")) +
  theme_minimal(base_size = 10) +
  theme(legend.position = "top") +
  labs(
    title = "Measurement Error",
    subtitle = "Observed vs true values",
    x = "Time",
    y = "Biomarker Value",
    color = ""
  )

# Combine plots side by side
p1 | p2
```

The left panel shows the complete ODE dynamics for four randomly selected subjects, illustrating how the biomarker value, velocity, and acceleration evolve over time. The right panel demonstrates the impact of random intercept and measurement error by comparing the true biomarker trajectories (lines) with the observed measurements (points).

```{r ode-stats, echo=FALSE}
# Calculate variance and correlation
ode_stats <- long_data %>%
  select(biomarker, velocity, acceleration) %>%
  summarise(
    var_biomarker = var(biomarker),
    var_velocity = var(velocity),
    var_acceleration = var(acceleration)
  )

ode_cor <- cor(long_data[c("biomarker", "velocity", "acceleration")])

# Display statistics
cat("Variance Components:\n")
cat(sprintf("  Biomarker: %.3f\n", ode_stats$var_biomarker))
cat(sprintf("  Velocity: %.3f\n", ode_stats$var_velocity))
cat(sprintf("  Acceleration: %.3f\n", ode_stats$var_acceleration))

cat("\nPairwise Correlations:\n")
cat(sprintf("  ρ(Biomarker, Velocity): %.3f\n", ode_cor[1, 2]))
cat(sprintf("  ρ(Biomarker, Acceleration): %.3f\n", ode_cor[1, 3]))
cat(sprintf("  ρ(Velocity, Acceleration): %.3f\n", ode_cor[2, 3]))
```

The variance hierarchy and correlation structure reflect the fundamental properties of the ODE system. Unlike independent variables in traditional models, these components are mechanistically linked through differential equations, creating intrinsic dependencies that capture the true dynamics of biomarker evolution.


### Survival Distribution

```{r viz-survival, fig.height=3, echo=FALSE}
# Kaplan-Meier curve
km_fit <- survfit(Surv(time, status) ~ 1, data = surv_data)

plot(km_fit,
  xlab = "Time",
  ylab = "Survival Probability",
  main = "Kaplan-Meier Survival Curve",
  conf.int = TRUE,
  mark.time = FALSE,
  lwd = 2.5,
  col = "#2C3E50",
  conf.int.style = "step",
  conf.int.fill = "#E8F4F8"
)
grid(lty = 2, col = "gray85")

# Add median survival line
if (!is.na(median(km_fit))) {
  abline(h = 0.5, lty = 2, col = "gray60")
  abline(v = median(km_fit), lty = 2, col = "gray60")
  text(median(km_fit) + 0.5, 0.05,
    sprintf("Median: %.1f", median(km_fit)),
    cex = 0.9, col = "gray40"
  )
}
```

The survival curve shows the overall event pattern in the simulated dataset, with the shaded area representing the 95% confidence interval.

## Model Comparison

We compare our proposed method against existing approaches:

| Model | Method Type | Data Source | Key Features |
|-------|------------|-------------|--------------|
| **JointODE** | Proposed | Noisy observations | ODE-based; estimates m(t), ṁ(t), m̈(t) |
| **JSM** | Baseline | Noisy observations | Linear mixed effects; only models m(t) |
| **Time-varying Cox (Oracle)** | Upper bound | True ODE values + $b_i$ | MPLE benchmark with true values |

The Oracle model uses the true biomarker trajectory, derivatives, and random effects at observed time points. While it has perfect information, it approximates the time-varying covariates using piecewise linear interpolation rather than modeling the continuous ODE dynamics.

Based on 200 simulation replicates, we evaluate the estimation accuracy of the association parameters $(\alpha_1, \alpha_2)$ and baseline covariate effects $(\phi_1, \phi_2)$ using Bias, Empirical Standard Error (ESE), Average Standard Error (ASE), and Coverage Probability (CP) of 95% confidence intervals.


```{r simulation-figure, echo=FALSE, fig.cap="Simulation Results", out.width="100%"}
knitr::include_graphics("../man/figures/simulation-1.png")
```

The simulation results demonstrate good estimation accuracy for the joint ODE-Cox model across different sample sizes. For $n=400$, the JointODE method yields minimal biases for both association parameters $\alpha_1$ and $\alpha_2$, as well as the baseline covariate effects $\phi_1$ and $\phi_2$. The coverage probabilities remain close to the nominal 95% level, indicating proper uncertainty quantification.

## Appendix

```{r model-implementation, eval=FALSE}
# Data preparation for comparison models
jsm_data <- dataPreprocess(
  long = sim$data$longitudinal_data %>% rename(ID = id),
  surv = sim$data$survival_data %>% rename(ID = id, survtime = time),
  id.col = "ID",
  long.time.col = "time",
  surv.time.col = "survtime",
  surv.event.col = "status"
) %>%
  rename(
    obstime = time,
    start = start.join,
    stop = stop.join,
    event = event.join
  ) %>%
  select(
    ID, obstime, observed, biomarker, velocity, acceleration,
    x1, x2, w1, w2, b, start, stop, event
  )

#--------------------------------------------
# Model 1: JointODE (Proposed Method)
#--------------------------------------------
fit_jointode <- JointODE(
  longitudinal_formula = observed ~ x1 + x2,
  survival_formula = Surv(time, status) ~ w1 + w2,
  longitudinal_data = sim$data$longitudinal_data,
  survival_data = sim$data$survival_data,
  state = as.matrix(sim$data$state)
)

#--------------------------------------------
# Model 2: Traditional Joint Model (JSM)
#--------------------------------------------
# Step 1: Longitudinal sub-model with natural splines
fit_lme <- lme(
  observed ~ x1 * bs(obstime, df = 5, Boundary.knots = c(0, 10)) +
    x2 * bs(obstime, df = 5, Boundary.knots = c(0, 10)),
  random = ~ 1 | ID,
  data = jsm_data
)

# Step 2: Survival sub-model
fit_cox <- coxph(
  Surv(start, stop, event) ~ w1 + w2 + cluster(ID),
  data = jsm_data, x = TRUE
)

# Step 3: Joint model
fit_jsm <- jmodelTM(
  fit_lme, fit_cox,
  data = jsm_data,
  timeVarY = "obstime"
)

#--------------------------------------------
# Model 3: Time-varying Cox (Oracle - Theoretical Benchmark)
#--------------------------------------------
fit_oracle <- coxph(
  Surv(start, stop, event) ~ biomarker + velocity  + w1 + w2 +
    offset(b) + cluster(ID),
  data = jsm_data
)
```


## Real Data Example

```{r example, eval=FALSE}
data(pbc)

#--------------------------------------------
# Model 1: Traditional JSM (使用原始pbc数据)
#--------------------------------------------
fit_lme_pbc <- lme(
  log(serBilir) ~ drug *
    bs(obstime, df = 4, degree = 2, Boundary.knots = c(0, 15)),
  random = ~ 1 | ID,
  data = pbc
)

fit_cox_pbc <- coxph(
  Surv(start, stop, event) ~ drug,
  data = pbc,
  x = TRUE
)

fit_jt_pbc <- jmodelTM(
  fit_lme_pbc, fit_cox_pbc, pbc,
  timeVarY = "obstime"
)

summary(fit_jt_pbc)

#--------------------------------------------
# Model 2: JointODE (使用分离的数据)
#--------------------------------------------
longitudinal_pbc <- pbc %>%
  select(ID, obstime, serBilir, drug) %>%
  filter(!is.na(serBilir)) %>%
  mutate(observed = log(serBilir)) %>%  # 取对数转换
  rename(id = ID, time = obstime) %>%
  select(id, time, observed, drug) %>%
  arrange(id, time)

survival_pbc <- pbc %>%
  group_by(ID) %>%
  slice_tail(n = 1) %>%  # 取每个患者的最后一条记录
  ungroup() %>%
  select(ID, Time, death, drug) %>%
  rename(
    id = ID,
    time = Time,  # 真实生存时间
    status = death  # 事件状态
  )

# 创建初始状态矩阵（使用第一次观测）
initial_states <- longitudinal_pbc %>%
  group_by(id) %>%
  slice(1) %>%
  ungroup() %>%
  select(id, observed) %>%
  mutate(
    velocity = 0  # 初始速度假设为0
  ) %>%
  arrange(id)

state_matrix <- as.matrix(initial_states[, c("observed", "velocity")])

fit_jointode_pbc <- JointODE(
  longitudinal_formula = observed ~ drug,
  survival_formula = Surv(time, status) ~ drug,
  longitudinal_data = longitudinal_pbc,
  survival_data = survival_pbc,
  state = state_matrix,
  parallel = TRUE,
  control = list(verbose = 3)
)

```
